# -*- coding: utf-8 -*-
"""Vectorization Best Practices

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12Tc4-LKyIfZsjM0DugzSYnTG3HuYYY0J
"""

"""
Day 2, Session 2, Topic 3: Best Practice: Never Use Python for Numeric Opsâ€”Vectorize!

This file explains why vectorization is crucial for efficient numerical
computation in Python and demonstrates how to use NumPy to achieve it.
It emphasizes the performance limitations of Python loops and the
advantages of vectorized operations.
"""

import numpy as np
import time

# -----------------------------------------------------------------------------
# The Problem with Python Loops
# -----------------------------------------------------------------------------
#
# Python, being an interpreted language, suffers from significant overhead
# when executing loops.  This overhead comes from the Python interpreter's
# execution model.
#
# Python Interpreter Overhead:
#
# 1.  Dynamic typing: In Python, the data type of a variable is determined
#     at runtime.  For each iteration of a loop, the interpreter has to
#     perform type checking to determine the operations that can be
#     applied to the data.  This repeated type checking adds overhead.
#
# 2.  Bytecode execution: Python code is first compiled into bytecode,
#     which is then interpreted by the Python Virtual Machine (PVM).
#     The PVM executes the bytecode instruction by instruction.  Each
#     instruction involves a significant amount of work for the
#     interpreter, including fetching the instruction, decoding it,
#     and executing it.
#
# 3.  Function call overhead: Operations within a Python loop often involve
#     function calls (e.g., addition, multiplication).  Each function
#     call in Python has overhead associated with setting up the
#     function's execution frame, passing arguments, and returning
#     the result.  This overhead is incurred in every loop iteration.
#
# Comparison with Vectorized Operations:
#
# Vectorized operations, as implemented in NumPy, avoid these sources of
# overhead.  NumPy operations are performed on entire arrays at once,
# rather than on individual elements within a loop.  This allows NumPy to:
#
# -   Perform type checking only once for the entire array, instead of
#     for each element.
# -   Execute the core computation in highly optimized, pre-compiled C
#     code, bypassing the Python interpreter's bytecode execution loop.
# -   Minimize function call overhead by performing operations on large
#     chunks of data with a single function call.
#
# Visual Representation:
#
# Python Loop:
#
# for i in range(len(array)):
#     result[i] = function(array[i])  #  ^
#     ^                               #  |  Interpreter overhead:
#     |                               #  |  - Type checking
#     |                               #  |  - Bytecode execution
#     Loop control                      #  |  - Function call setup/teardown
#
# Vectorized Operation (NumPy):
#
# result = numpy_function(array)  #  No per-element Python loop
#   ^
#   |
#   Optimized C code applied to the entire array
#
# Example: Python loop vs. NumPy vectorization
def compare_loop_vs_vectorization(size=1000000):
    a = np.random.rand(size)
    b = np.random.rand(size)
    result_loop = np.zeros(size)
    result_vectorized = np.zeros(size)

    # Using a Python loop (slow)
    def python_loop_add(x, y, out):
        for i in range(len(x)):
            out[i] = x[i] + y[i]

    # Using NumPy's vectorized addition (fast)
    def numpy_vectorized_add(x, y):
        return x + y  # Or np.add(x, y)

    # Time the Python loop
    start_time = time.time()
    python_loop_add(a, b, result_loop)
    python_time = time.time() - start_time
    print(f"Python loop addition time: {python_time:.4f} seconds")

    # Time the vectorized operation
    start_time = time.time()
    result_vectorized = numpy_vectorized_add(a, b)
    numpy_time = time.time() - start_time
    print(f"NumPy vectorized addition time: {numpy_time:.4f} seconds")

    print(f"Speedup: {python_time / numpy_time:.2f}x")
    np.testing.assert_allclose(result_loop, result_vectorized)
    return a,b #returning a and b for use in other functions

# -----------------------------------------------------------------------------
# Vectorization with NumPy
# -----------------------------------------------------------------------------
#
# NumPy provides a powerful way to perform vectorized operations on arrays.
# Vectorization replaces explicit Python loops with highly optimized C code
# that operates on entire arrays at once.
#
# NumPy Universal Functions (Ufuncs):
#
# The key to vectorization in NumPy is the concept of universal functions
# (ufuncs).  Ufuncs are functions that perform element-wise operations on
# ndarrays.  They are implemented in C and are designed to be extremely fast.
#
# Examples of ufuncs:
#
# -   Arithmetic: `np.add()`, `np.subtract()`, `np.multiply()`, `np.divide()`, `np.power()`
# -   Trigonometric: `np.sin()`, `np.cos()`, `np.tan()`, `np.arcsin()`, `np.arccos()`, `np.arctan()`
# -   Exponential and logarithmic: `np.exp()`, `np.log()`, `np.log10()`
# -   Comparison: `np.equal()`, `np.not_equal()`, `np.less()`, `np.greater()`
# -   Other: `np.abs()`, `np.sqrt()`, `np.floor()`, `np.ceil()`
#
# How Vectorization Eliminates Python Loops:
#
# Instead of writing a Python loop to iterate over the elements of an array
# and perform an operation on each element, you simply apply the ufunc to
# the entire array.  NumPy handles the looping internally, using optimized C
# code.
#
# Example: Vectorized operations with NumPy
def demonstrate_numpy_vectorization(x,y):
    # Create two NumPy arrays
    a = x
    b = y

    # Vectorized addition
    result_add = a + b  # Equivalent to np.add(a, b)
    print("Vectorized addition:")
    print(result_add[:5])  # Print the first 5 elements

    # Vectorized multiplication
    result_mul = a * b  # Equivalent to np.multiply(a, b)
    print("\nVectorized multiplication:")
    print(result_mul[:5])

    # Vectorized exponentiation
    result_pow = np.power(a, 2)
    print("\nVectorized exponentiation:")
    print(result_pow[:5])

    # Vectorized sine function
    result_sin = np.sin(a)
    print("\nVectorized sine function:")
    print(result_sin[:5])

    # Vectorized comparison
    result_comp = a > b
    print("\nVectorized comparison (a > b):")
    print(result_comp[:5])
    return a,b

# -----------------------------------------------------------------------------
# Benefits of Vectorization
# -----------------------------------------------------------------------------
#
# Vectorization offers several significant advantages over using Python loops
# for numerical operations.
#
# Performance Gains:
#
# Vectorized operations can be orders of magnitude faster than equivalent
# operations performed with Python loops.  The exact speedup depends on the
# specific operation, the size of the arrays, and the hardware.  However,
# speedups of 10x to 100x or more are common.
#
# Conciseness and Readability:
#
# Vectorized code is often much more concise and easier to read than code
# that uses explicit loops.  Instead of writing a multi-line loop, you can
# express the operation in a single line of code.  This makes your code
# more compact and easier to understand.
#
# Example: Comparing code conciseness
def demonstrate_code_conciseness(x,y):
    a = x
    b = y
    # Python loop (verbose)
    def python_loop_multiply_and_add(x, y):
        result = np.zeros_like(x)
        for i in range(len(x)):
            result[i] = x[i] * y[i] + x[i]
        return result

    # Vectorized operation (concise)
    def numpy_vectorized_multiply_and_add(x, y):
        return x * y + x

    result_loop = python_loop_multiply_and_add(a, b)
    result_vectorized = numpy_vectorized_multiply_and_add(a, b)
    print("Python loop result (first 5 elements):")
    print(result_loop[:5])
    print("\nVectorized result (first 5 elements):")
    print(result_vectorized[:5])
    np.testing.assert_allclose(result_loop, result_vectorized)
    return a,b

# -----------------------------------------------------------------------------
# Advanced Vectorization Techniques
# -----------------------------------------------------------------------------
#
# NumPy provides several advanced techniques that can further enhance the
# power and flexibility of vectorization.
#
# Broadcasting:
#
# As discussed in the previous topic, broadcasting allows you to perform
# operations on arrays with different shapes.  Broadcasting is a powerful
# tool for vectorization because it allows you to avoid explicit loops
# when operating on arrays that do not have the same shape.
#
# Fancy Indexing:
#
# Fancy indexing allows you to use arrays of indices to access multiple
# array elements at once.  This is more efficient than using a Python loop
# to access elements one by one.
#
# Boolean Indexing:
#
# Boolean indexing allows you to select array elements based on a condition.
# You create a boolean array that has the same shape as the array you
# want to index, and then use this boolean array to select the elements
# where the boolean array is `True`.
#
# Example: Advanced vectorization techniques
def demonstrate_advanced_vectorization(a,b):
    # Create a sample array
    data = np.array([[1, 2, 3, 4],
                     [5, 6, 7, 8],
                     [9, 10, 11, 12]])

    print("Original array:")
    print(data)

    # Broadcasting example
    b = np.array([10, 20, 30, 40])  # Shape (4,)
    result_broadcast = data + b       # b is broadcasted to (3, 4)
    print("\nBroadcasting example (data + b):")
    print(result_broadcast)

    # Fancy indexing example
    indices = np.array([0, 2, 1])  # Select rows 0, 2, and 1
    result_fancy = data[indices]
    print("\nFancy indexing example (select rows 0, 2, 1):")
    print(result_fancy)

    # Select specific elements using fancy indexing
    row_indices = np.array([0, 1, 2])
    col_indices = np.array([1, 2, 3])
    result_fancy_elements = data[row_indices, col_indices] # (0,1), (1,2), (2,3)
    print("\nFancy indexing to select specific elements:")
    print(result_fancy_elements)

    # Boolean indexing example
    condition = data > 5
    result_boolean = data[condition]
    print("\nBoolean indexing example (elements > 5):")
    print(result_boolean)

    # Using boolean indexing to modify values
    data[condition] = 0
    print("\nArray after modifying elements > 5 to 0:")
    print(data)
    return data

# -----------------------------------------------------------------------------
# When Vectorization Might Not Be Enough
# -----------------------------------------------------------------------------
#
# While vectorization is a powerful technique, there are some situations where
# it might not be sufficient or optimal.
#
# Memory Limitations:
#
# Vectorized operations often involve creating temporary arrays to store
# intermediate results.  When dealing with extremely large datasets, these
# temporary arrays can consume a significant amount of memory, potentially
# leading to memory errors or performance degradation due to excessive
# swapping.  In such cases, you might need to consider alternative
# approaches, such as:
#
# -   Chunking: Processing the data in smaller chunks using loops, but
#     applying vectorized operations within each chunk.
# -   Memory mapping: Using memory-mapped files to access data on disk
#     without loading the entire dataset into memory.
# -   Out-of-core computing: Using libraries like Dask to perform
#     computations on datasets that are too large to fit into memory.
#
# Complex Operations:
#
# Some operations are difficult or impossible to express directly as
# vectorized operations.  For example, operations that involve complex
# dependencies between elements or that require state to be maintained
# across iterations might be challenging to vectorize.  In such cases,
# you might need to use a combination of vectorization and explicit
# loops, or consider using JIT compilation (as discussed in the previous
# topic) to accelerate the loops.
#
# Example: Operation that is hard to vectorize
def example_non_vectorizable(data):
    """
    This function calculates cumulative sums with a condition,
    which is difficult to vectorize directly.
    """
    result = np.zeros_like(data)
    cumulative_sum = 0
    for i in range(data.shape[0]):
        for j in range(data.shape[1]):
            if data[i, j] > 0:
                cumulative_sum += data[i, j]
            result[i, j] = cumulative_sum
    return result
# -----------------------------------------------------------------------------
# Code Examples
# -----------------------------------------------------------------------------
#
# The previous sections have included several code examples. This section
# serves as a recap and provides a consolidated view.
#
# -----------------------------------------------------------------------------
# Challenge
# -----------------------------------------------------------------------------
#
# Challenge Description:
#
# You are given a 2D NumPy array representing a grayscale image.  You need to
# apply a non-linear transformation to the image to enhance its contrast.
# The transformation is defined as follows:
#
#   output_pixel = 255 * (input_pixel / 255)**gamma
#
# where:
#
# -   `input_pixel` is the grayscale value of a pixel (0-255).
# -   `gamma` is a parameter that controls the shape of the transformation curve.
#
# Your task is to write a function that performs this non-linear contrast
# adjustment efficiently using NumPy vectorization.  Avoid using explicit
# Python loops.
#
# Input:
#
# -   `image`: A 2D NumPy array of shape (height, width) representing the grayscale image.
#     The data type of the array is `np.uint8`.
# -   `gamma`: A float representing the gamma value.
#
# Output:
#
# -   A new 2D NumPy array of the same shape as the input image, representing the
#     contrast-adjusted image.  The data type of the array should be `np.uint8`.
#
# Solution
def adjust_contrast_gamma(image, gamma):
    """
    Adjusts the contrast of a grayscale image using a gamma transformation.

    Args:
        image: A 2D NumPy array representing the grayscale image (np.uint8).
        gamma: The gamma value (float).

    Returns:
        A new 2D NumPy array representing the contrast-adjusted image (np.uint8).
    """
    # Vectorized implementation
    normalized_image = image / 255.0  # Normalize to 0-1 range
    adjusted_normalized = normalized_image**gamma
    adjusted_image = (adjusted_normalized * 255).astype(np.uint8)
    return adjusted_image
def create_test_image():
    """
    Creates a sample grayscale image for testing.
    """
    image = np.array([[0, 50, 100],
                      [150, 200, 255],
                      [25, 75, 125]], dtype=np.uint8)
    return image

if __name__ == "__main__":
    print("Comparing Loop vs. Vectorization:")
    a,b = compare_loop_vs_vectorization()
    a,b = demonstrate_numpy_vectorization(a,b)
    a,b = demonstrate_code_conciseness(a,b)
    data = demonstrate_advanced_vectorization(a,b)
    print("\nExample of non vectorizable:")
    print(example_non_vectorizable(data))

    print("\nRunning Challenge:")
    test_image = create_test_image()
    gamma_value = 2.2
    adjusted_image = adjust_contrast_gamma(test_image, gamma_value)

    print("Original Image:")
    print(test_image)
    print(f"\nAdjusted Image (gamma = {gamma_value}):")
    print(adjusted_image)