# -*- coding: utf-8 -*-
"""Image Processing Challenge (NumPy + Numexpr)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19DaSFi73Tsw48c0ZvuAWeRwjv7X5dTu5
"""

"""
Day 2, Session 2, Topic 4: Challenge - Rewrite a CPU-bound Image Processing Loop using NumPy + Numexpr

This file presents a challenge involving the optimization of a CPU-bound image
processing loop.  It provides a detailed explanation of the problem,
a naive solution using Python loops, and an optimized solution using
NumPy and Numexpr.  The focus is on demonstrating the performance
benefits of vectorization and expression optimization for image processing.
"""

import numpy as np
import time
import numexpr as ne

# -----------------------------------------------------------------------------
# Challenge Description
# -----------------------------------------------------------------------------
#
# You are given a grayscale image represented as a 2D NumPy array.  Your task is to
# implement a function that applies a complex, pixel-wise transformation to this
# image.  The transformation is designed to be computationally intensive,
# simulating a CPU-bound image processing task.
#
# The transformation to be applied to each pixel is as follows:
#
#   output_pixel = (255.0 * (input_pixel / 255.0)**gamma) * a + b * log(c * input_pixel + d)
#
# where:
#
# -   `input_pixel`: The grayscale value of a pixel in the input image (0-255).
# -   `gamma`, `a`, `b`, `c`, `d`:  Floating-point constants that control the
#       transformation.
# -   `log`: The natural logarithm.
#
# The goal is to implement this transformation as efficiently as possible,
# leveraging NumPy and Numexpr to avoid slow Python loops.
#
# Input:
#
# -   `image`: A 2D NumPy array of shape (height, width) representing the grayscale image.
#     The data type of the array is `np.uint8`.
# -   `gamma`, `a`, `b`, `c`, `d`: Floating-point constants.
#
# Output:
#
# -   A new 2D NumPy array of the same shape as the input image, representing the
#     transformed image.  The data type of the array should be `np.uint8`.
#
# -----------------------------------------------------------------------------
# Naive Solution: Python Loops
# -----------------------------------------------------------------------------
#
# A straightforward, but inefficient, way to implement this transformation is to
# use nested Python loops to iterate over the pixels of the image.
#
def transform_image_python_loops(image, gamma, a, b, c, d):
    """
    Applies the pixel transformation using Python loops.

    Args:
        image: A 2D NumPy array (np.uint8).
        gamma, a, b, c, d: Floating-point constants.

    Returns:
        A 2D NumPy array (np.uint8) representing the transformed image.
    """
    height, width = image.shape
    transformed_image = np.zeros((height, width), dtype=np.uint8)
    for y in range(height):
        for x in range(width):
            input_pixel = image[y, x]
            # Avoid log(0)
            if input_pixel == 0:
                transformed_image[y, x] = 0
            else:
                normalized_pixel = input_pixel / 255.0
                output_pixel = (255.0 * (normalized_pixel**gamma) * a +
                                b * np.log(c * input_pixel + d))
                transformed_image[y, x] = np.clip(output_pixel, 0, 255).astype(np.uint8)
    return transformed_image
# -----------------------------------------------------------------------------
# Optimized Solution: NumPy + Numexpr
# -----------------------------------------------------------------------------
#
# A much more efficient solution is to use NumPy for array operations and Numexpr
# to optimize the evaluation of the complex expression.
#
# Key Optimizations:
#
# 1.  Vectorization: NumPy allows us to perform the operations on the entire
#     image array at once, eliminating the need for explicit Python loops.
#
# 2.  Numexpr: Numexpr optimizes the evaluation of the complex arithmetic
#     expression.  It can take advantage of multiple CPU cores and avoid
#     the creation of large temporary arrays.
#
def transform_image_numpy_numexpr(image, gamma, a, b, c, d):
    """
    Applies the pixel transformation using NumPy and Numexpr.

    Args:
        image: A 2D NumPy array (np.uint8).
        gamma, a, b, c, d: Floating-point constants.

    Returns:
        A 2D NumPy array (np.uint8) representing the transformed image.
    """
    # Convert the image to float for calculations
    float_image = image.astype(np.float64)
    normalized_image = float_image / 255.0
    # Use Numexpr to evaluate the expression
    expression = "255.0 * (normalized_image**gamma) * a + b * log(c * float_image + d)"
    transformed_image = ne.evaluate(expression)
    # Clip and convert to uint8
    return np.clip(transformed_image, 0, 255).astype(np.uint8)
# -----------------------------------------------------------------------------
# Visual Representation of Optimization
# -----------------------------------------------------------------------------
#
# Imagine the image as a grid of pixels.
#
# Naive Approach (Python Loops):
#
# +-------+-------+-------+  For each pixel:
# | P1    | P2    | P3    |    1. Fetch pixel value
# |       |       |       |    2. Perform calculation
# +-------+-------+-------+    3. Store result
# | P4    | P5    | P6    |
# |       |       |       |
# +-------+-------+-------+
# | P7    | P8    | P9    |
# |       |       |       |
# +-------+-------+-------+
#
# Optimized Approach (NumPy + Numexpr):
#
# +-------+-------+-------+  1. Fetch entire image array
# | P1    | P2    | P3    |  2. Perform vectorized calculation
# |       |       |       |     using optimized C code and Numexpr VM
# +-------+-------+-------+  3. Store entire result array
# | P4    | P5    | P6    |
# |       |       |       |
# +-------+-------+-------+
# | P7    | P8    | P9    |
# |       |       |       |
# +-------+-------+-------+
#
# The optimized approach processes the entire image at once, eliminating the
# overhead of the Python interpreter for each pixel.
#
# -----------------------------------------------------------------------------
# Performance Comparison
# -----------------------------------------------------------------------------
#
# The following code demonstrates the performance difference between the naive
# Python loop implementation and the optimized NumPy + Numexpr implementation.
#
def compare_performance(image, gamma, a, b, c, d):
    """
    Compares the performance of the Python loop and NumPy + Numexpr implementations.

    Args:
        image: A 2D NumPy array (np.uint8).
        gamma, a, b, c, d: Floating-point constants.
    """
    start_time = time.time()
    transformed_image_python = transform_image_python_loops(image, gamma, a, b, c, d)
    python_time = time.time() - start_time
    print(f"Python loop time: {python_time:.4f} seconds")

    start_time = time.time()
    transformed_image_numexpr = transform_image_numpy_numexpr(image, gamma, a, b, c, d)
    numexpr_time = time.time() - start_time
    print(f"NumPy + Numexpr time: {numexpr_time:.4f} seconds")

    print(f"Speedup: {python_time / numexpr_time:.2f}x")
    np.testing.assert_allclose(transformed_image_python, transformed_image_numexpr)

# -----------------------------------------------------------------------------
# Example Usage
# -----------------------------------------------------------------------------
#
# The following code demonstrates how to use the optimized
# `transform_image_numpy_numexpr` function.
#
if __name__ == "__main__":
    # Create a sample image
    image = np.random.randint(0, 256, size=(1024, 1024), dtype=np.uint8)
    # Set the transformation parameters
    gamma = 2.2
    a = 1.5
    b = 10.0
    c = 0.01
    d = 1.0

    print("Running Performance Comparison:")
    compare_performance(image, gamma, a, b, c, d)

    # Apply the transformation
    transformed_image = transform_image_numpy_numexpr(image, gamma, a, b, c, d)

    # Display the original and transformed images (optional, requires matplotlib)
    try:
        import matplotlib.pyplot as plt
        plt.figure(figsize=(10, 5))
        plt.subplot(1, 2, 1)
        plt.imshow(image, cmap='gray')
        plt.title('Original Image')
        plt.subplot(1, 2, 2)
        plt.imshow(transformed_image, cmap='gray')
        plt.title('Transformed Image')
        plt.show()
    except ImportError:
        print("Matplotlib not installed, skipping image display.")
        print("Transformed image shape:", transformed_image.shape)
        print("Transformed image data type:", transformed_image.dtype)