# -*- coding: utf-8 -*-
"""uvloop, I/O Bound Optimizations

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yHIcQyULwIdaktzGn81DeX3iOZgjuqOU
"""

"""
Day 3, Session 3, Topic 3: uvloop, I/O Bound Optimizations

This file explains how to optimize I/O-bound operations in Python using
asyncio and the uvloop library.  It provides a detailed explanation
of the asyncio event loop, uvloop, and other I/O optimization techniques.
"""

import asyncio
import time
import requests  # For comparison with asyncio
import aiohttp  # For asyncio HTTP requests
import sys

# -----------------------------------------------------------------------------
# asyncio Event Loop
# -----------------------------------------------------------------------------
#
# The asyncio event loop is the core component of asyncio. It is a
# single-threaded loop that manages the execution of asynchronous tasks
# (coroutines).
#
# How the Event Loop Works:
#
# 1.  Registration: Asynchronous operations (e.g., network I/O, file I/O)
#     are registered with the event loop.  This registration typically
#     involves providing a callback function that will be executed when
#     the operation completes.
#
# 2.  Looping: The event loop continuously loops, monitoring the registered
#     operations for completion.
#
# 3.  Event Notification: When an operation completes, the operating system
#     or the underlying library (e.g., libuv) notifies the event loop.
#
# 4.  Callback Execution: The event loop then schedules the corresponding
#     callback function to be executed.  This callback function is
#     typically a coroutine that uses `await` to wait for the result
#     of the operation.
#
# 5.  Coroutine Resumption: The event loop resumes the execution of the
#     coroutine at the point where it was suspended by the `await`
#     expression.
#
# 6.  Loop Continuation: The event loop continues looping, processing
#     other events and resuming other coroutines until all tasks are
#     completed.
#
# Visual Representation (Simplified):
#
# +-----------------+
# |   Event Loop    |
# +-----------------+
#         |
#         | Registration of I/O operations, callbacks
#         |
# +-----------------+  +-----------------+  +-----------------+
# |   I/O Op 1    |  |   I/O Op 2    |  |   I/O Op 3    |  ...
# +-----------------+  +-----------------+  +-----------------+
#         |                  |                  |
#         |                  |                  | Completion notification
#         \------------------+------------------/
#                                 |
#                                 |
#         +-----------------+
#         | Callback Queue  |
#         +-----------------+
#                                 |
#                                 | Callback execution, coroutine resumption
#                                 |
#         +-----------------+
#         |   Coroutines    |
#         +-----------------+
#
# -----------------------------------------------------------------------------
# uvloop
# -----------------------------------------------------------------------------
#
# uvloop is a high-performance event loop implementation for asyncio.
# It is based on libuv, the same library that powers Node.js.
#
# Why uvloop?
#
# -   Performance: uvloop is significantly faster than the default asyncio
#     event loop, especially for I/O-bound operations.  It is designed
#     for high concurrency and low latency.
#
# -   libuv:  uvloop leverages the power of libuv, which is highly
#     optimized for handling I/O.
#
# -  Drop-in replacement: uvloop is designed to be a drop-in replacement
#     for the default asyncio event loop.  You can often use uvloop
#     without changing your asyncio code.
#
# Performance Comparison: uvloop vs. Default asyncio Loop
#
# The following example demonstrates the performance difference between
# the default asyncio event loop and uvloop for a simple I/O-bound task
# (making multiple HTTP requests).
#
async def fetch_url(session, url):
    """
    Fetches the content of a URL using aiohttp.

    Args:
        session: aiohttp ClientSession
        url: The URL to fetch.

    Returns:
        The content of the URL as bytes.
    """
    try:
        async with session.get(url) as response:
            await response.read()  # Read the entire response body
            return response.status
    except Exception as e:
        print(f"Error fetching {url}: {e}")
        return None

async def run_fetch_tasks(loop, urls):
    """
    Runs multiple fetch tasks concurrently using the given event loop.

    Args:
        loop: The asyncio event loop.
        urls: A list of URLs to fetch.
    """
    async with aiohttp.ClientSession(loop=loop) as session:
        tasks = [fetch_url(session, url) for url in urls]
        # Await all tasks and get results
        results = await asyncio.gather(*tasks)
        return results

def demonstrate_uvloop_performance():
    """
    Demonstrates the performance benefits of uvloop.
    """
    urls = [
        "https://www.google.com" for _ in range(100)  # 100 requests to the same URL
    ]

    # Check if there is a running loop.
    try:
        running_loop = asyncio.get_running_loop()
    except AttributeError:  # Python 3.6 doesn't have get_running_loop
        running_loop = None
    except RuntimeError:
        running_loop = None

    if running_loop:
        # If there is a running loop, use it.
        loop = running_loop
    else:
        # Otherwise, create a new loop.
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    try:
        # Test with default asyncio loop
        start_time = time.time()
        results = loop.run_until_complete(run_fetch_tasks(loop, urls))
        default_loop_time = time.time() - start_time
        print(f"Default asyncio loop time: {default_loop_time:.4f} seconds")

        # Test with uvloop (if available)
        try:
            import uvloop
            asyncio.set_event_loop_policy(uvloop.get_event_loop_policy())
            new_loop = asyncio.get_event_loop()  # get the uvloop
            start_time = time.time()
            results_uv = new_loop.run_until_complete(run_fetch_tasks(new_loop, urls))
            uvloop_time = time.time() - start_time
            print(f"uvloop time: {uvloop_time:.4f} seconds")
            print(f"uvloop speedup: {default_loop_time / uvloop_time:.2f}x")
        except ImportError:
            print("uvloop is not installed. Skipping uvloop test.")
        finally:
            if not running_loop:
                loop.close()
    except Exception as e:
        print(f"An error occurred: {e}")
        if not running_loop:
            loop.close()
        raise  # Re-raise the exception