# -*- coding: utf-8 -*-
"""Common Anti-patterns (e.g., Default Mutable Args)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12-MpLZ-GQV3aO7d5E0Q_AS3QRQUYo-u2
"""

"""
Day 3, Session 1, Topic 4: Common Anti-patterns (e.g., Default Mutable Args)

This file covers common anti-patterns in Python, with a focus on default mutable arguments
and how they can lead to unexpected behavior and performance issues.  It also includes
benchmarks to demonstrate the performance implications.
"""

# 4. Common Anti-patterns (e.g., Default Mutable Args)
# -----------------------------------------------------------
# Concept:
#    -   Default Mutable Arguments:  Using mutable objects (like lists or dictionaries)
#        as default values for function parameters.  This is a common source of bugs
#        and unexpected behavior in Python.
#
# Why is it important?
#    -   Unexpected Behavior:  Default mutable arguments are created only once
#        when the function is defined, not each time the function is called.
#        This means that if the mutable object is modified within the function,
#        the modification persists across subsequent calls to the function.
#    -   Bugs:  This behavior can lead to subtle and hard-to-find bugs, as the
#        function's state can be unintentionally shared between invocations.
#    -   Performance:  While the primary issue is correctness, there can be
#        performance implications if you are unintentionally modifying a large
#        mutable default argument.
#
# Default Mutable Arguments
# --------------------------
# Internal Implementation:
#    -   When a function is defined, the default values of its parameters are
#        evaluated once and stored in the function's `__defaults__` attribute
#        (for positional arguments) and `__kwdefaults__` attribute (for keyword
#        arguments).
#    -   These default values are bound to the function object, not to each
#        invocation of the function.
#    -   If a default value is a mutable object, and that object is modified
#        by the function, the *same* object is modified each time the function
#        is called without an explicit argument for that parameter.
#
# How to Use:
#    -   The Anti-Pattern:  Avoid using mutable objects as default arguments.
#
# How it Works:
#     -  The default value is evaluated when the function is defined.
#     -  The default value is stored as part of the function object.
#     -  If the caller does not provide a value for that argument, the stored default value is used.
#     -  If the default value is mutable and is changed by the function, the stored value is changed.
#
# When Not to Use:
#    -   *Never* use mutable objects (lists, dictionaries, sets, etc.) as default
#        argument values, unless you *explicitly* intend to share state between
#        function calls (which is almost never the right approach).
#
# Example:
import time
import sys

def bad_function(my_list=[]):
    """
    Demonstrates the anti-pattern of using a mutable default argument.
    """
    my_list.append(1)
    return my_list

def good_function(my_list=None):
    """
    Demonstrates the correct way to handle optional mutable arguments.
    """
    if my_list is None:
        my_list = []
    my_list.append(1)
    return my_list

def benchmark_mutable_default(n):
    """Benchmarks the performance of the bad and good functions."""
    start_time = time.time()
    for _ in range(n):
        bad_function()
    bad_time = time.time() - start_time
    bad_memory = sys.getsizeof(bad_function()) # rough estimate.  the list grows.

    start_time = time.time()
    for _ in range(n):
        good_function()
    good_time = time.time() - start_time
    good_memory = sys.getsizeof(good_function()) # rough estimate. the list grows, but slower

    print(f"For {n} iterations:")
    print(f"  bad_function:  Time = {bad_time:.6f} sec, Memory = {bad_memory} bytes")
    print(f"  good_function: Time = {good_time:.6f} sec, Memory = {good_memory} bytes")



# Demonstrate the anti-pattern
print("Demonstrating the anti-pattern:")
print(bad_function())  # Output: [1]
print(bad_function())  # Output: [1, 1]  <-- Unexpected!
print(bad_function())  # Output: [1, 1, 1] <-- Unexpected!

# Demonstrate the correct way
print("\nDemonstrating the correct way:")
print(good_function())  # Output: [1]
print(good_function())  # Output: [1]
print(good_function())  # Output: [1]

#Demonstrate that the default list is created only once.
def show_default_list_identity():
    def f(a=[]):
        print(id(a))
        a.append(1)
    f()
    f()
    f()

show_default_list_identity()

benchmark_mutable_default(10000)
benchmark_mutable_default(100000)