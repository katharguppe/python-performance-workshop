# -*- coding: utf-8 -*-
"""Lazy Evaluation, itertools, and Generator Expressions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HCuObQNY8Egn9LocD7-OkoKKBwML7zM8
"""

"""
Day 3, Session 1, Topic 3: Lazy Evaluation, itertools, and Generator Expressions

This file covers lazy evaluation in Python, focusing on itertools and generator expressions.
"""

# 3. Lazy Evaluation, itertools, and Generator Expressions
# -----------------------------------------------------------
# Concept:
#    -   Lazy Evaluation:  Delaying the evaluation of an expression until its
#        value is actually needed.  Instead of computing values eagerly (immediately),
#        a lazy approach computes them only when accessed.
#    -   itertools:  A module providing a collection of iterator building blocks
#        for creating fast, memory-efficient tools.
#    -   Generator Expressions:  A concise way to create generator objects, similar
#        to list comprehensions but using parentheses `()` instead of square
#        brackets `[]`.
#
# Why is it important?
#    -   Memory Efficiency: Lazy evaluation avoids computing and storing
#        intermediate results that might not be needed.  This is crucial for
#        large or infinite sequences.
#    -   Performance:  By delaying computation, lazy evaluation can improve
#        performance by reducing the overall amount of work done, especially
#        when only a subset of the results is needed.
#    -   Code Readability:  Generator expressions provide a compact and
#        readable syntax for creating iterators.
#
# Lazy Evaluation
# ----------------
# Internal Implementation:
#     - Python's generator functions and expressions employ lazy evaluation.
#     - When a generator function is called, it returns a generator object
#       without executing the function's body.
#     - The generator object's `__next__` method executes the function until a
#       `yield` statement is encountered, returning the yielded value and
#       pausing the function's state.
#     - The state of the function is preserved, allowing it to resume execution
#       from where it left off when `__next__` is called again.
#
# itertools
# ---------
# Internal Implementation:
#    -   The `itertools` module is implemented in C for performance.
#    -   Functions like `count()`, `cycle()`, `repeat()` create iterators that
#        generate values on demand, often without storing the entire sequence
#        in memory.
#    -   Functions like `chain()`, `zip_longest()`, `islice()` create iterators
#        that operate on other iterators, combining or transforming them lazily.
#
# Generator Expressions
# ---------------------
# Internal Implementation:
#    -   Generator expressions are compiled into generator objects.
#    -   The bytecode for a generator expression is similar to that of a
#        generator function, using the `YIELD_VALUE` opcode.
#    -   The interpreter creates a frame object to store the state of the
#        generator expression, including local variables and the current
#        instruction pointer.
#
# How to Use:
#    -   Lazy Evaluation:  Use generator functions and generator expressions.
#    -   itertools:  Import the `itertools` module and use its functions to
#        create iterators.
#    -   Generator Expressions:  Use the syntax `(expr for var in iterable if condition)`.
#
# How it Works:
#    -   Lazy Evaluation: Values are computed only when requested by calling
#        `next()` on the iterator.
#    -   itertools:  Functions in `itertools` return iterators.  These iterators
#        produce values on demand, often by combining or transforming other
#        iterators.
#    -   Generator Expressions:  A generator object is created.  When `next()`
#        is called on the generator, the expression is evaluated for the next
#        value in the sequence.
#
# When Not to Use:
#    -   Lazy Evaluation:  If you need all the values immediately and want to
#        store them in a list for repeated access, a list comprehension might
#        be more appropriate.  However, for large datasets, prefer lazy evaluation.
#    -   itertools:  Use it whenever you're working with iterators and need
#        efficient, memory-friendly tools for combining, filtering, or
#        transforming them.  Avoid it if you're not working with iterators or
#        if you need the entire result in memory.
#    -   Generator Expressions:  Use them for simple iteration logic.  For more
#        complex logic, use a generator function.  If you need to create a list,
#        use a list comprehension.
#
# Example:
import itertools
import time
import sys

def show_lazy_evaluation():
    """Demonstrates lazy evaluation with a generator."""
    def my_generator(n):
        for i in range(n):
            print(f"Generating {i}")  # Print *before* yielding
            yield i * 2

    gen = my_generator(3)  # Generator object is created, but no code runs yet

    print("Start iteration")
    print(next(gen))  # 0 is generated and printed
    print(next(gen))  # 2 is generated and printed
    print(next(gen))  # 4 is generated and printed
    # print(next(gen))  # Raises StopIteration

def show_itertools():
    """Demonstrates using itertools."""
    # count(start, step): Generates an infinite sequence of numbers
    for i in itertools.islice(itertools.count(start=1, step=2), 5): # islice is used to limit the infinite sequence.
        print(i)  # Prints 1, 3, 5, 7, 9

    # cycle(iterable):  Cycles through the elements of an iterable indefinitely
    count = 0
    for item in itertools.cycle(['A', 'B', 'C']):
        print(item)
        count += 1
        if count > 5:
            break

    # chain(*iterables):  Chains multiple iterables together
    for item in itertools.chain([1, 2, 3], ['a', 'b', 'c']):
        print(item)  # Prints 1, 2, 3, a, b, c

def show_generator_expressions():
    """Demonstrates using generator expressions."""
    # Squares of even numbers from 0 to 9
    gen = (x**2 for x in range(10) if x % 2 == 0)
    print(gen) # Prints the generator object.
    for value in gen:
        print(value)  # Prints 0, 4, 16, 36, 64

def benchmark_comparison(n):
    """
    Compares the performance and memory usage of list comprehension,
    generator expression, and itertools.
    """
    # List comprehension
    start_time = time.time()
    list_result = [x**2 for x in range(n) if x % 2 == 0]
    list_time = time.time() - start_time
    list_memory = sys.getsizeof(list_result)

    # Generator expression
    start_time = time.time()
    gen_result = (x**2 for x in range(n) if x % 2 == 0)
    gen_time = time.time() - start_time
    gen_memory = sys.getsizeof(gen_result)

    # itertools (using map and filter for closer comparison)
    start_time = time.time()
    itertools_result = map(lambda x: x**2, filter(lambda x: x % 2 == 0, range(n)))
    itertools_time = time.time() - start_time
    itertools_memory = sys.getsizeof(itertools_result)

    print(f"For n = {n}:")
    print(f"  List comprehension:   Time = {list_time:.6f} sec, Memory = {list_memory} bytes")
    print(f"  Generator expression: Time = {gen_time:.6f} sec, Memory = {gen_memory} bytes")
    print(f"  itertools:            Time = {itertools_time:.6f} sec, Memory = {itertools_memory} bytes")

    # важно: list comprehension memory будет расти с n, а generators - нет.
    #  itertools memory может быть больше, чем у generator expression, но сильно меньше чем у list comprehension.


show_lazy_evaluation()
show_itertools()
show_generator_expressions()
benchmark_comparison(1000)
benchmark_comparison(10000)
benchmark_comparison(100000)